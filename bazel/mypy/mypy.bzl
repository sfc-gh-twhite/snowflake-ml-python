load("@bazel_skylib//lib:shell.bzl", "shell")
load("@bazel_skylib//lib:sets.bzl", "sets")

MyPyAspectInfo = provider(
    fields = {
        "out": "mypy output.",
        "cache": "cache generated by mypy.",
    },
)

# We don't support stubs (pyi) yet.
PY_EXTENSIONS = ["py"]
PY_RULES = ["py_binary", "py_library", "py_test", "py_wheel", "py_package"]

DEFAULT_ATTRS = {
    "_mypy_sh": attr.label(
        default = Label("//bazel/mypy:mypy.sh.tpl"),
        allow_single_file = True,
    ),
    "_mypy": attr.label(
        default = Label("//bazel/mypy:mypy"),
        executable = True,
        cfg = "host",
    ),
    "_mypy_config": attr.label(
        default = Label("//:mypy.ini"),
        allow_single_file = True,
    ),
    "_debug": attr.bool(
        default = False,
    )
}

# See https://github.com/python/mypy/pull/4759 for what `cache_map_triples` mean.
def _sources_to_cache_map_triples(cache_files, dep_cache_files):
    triples_as_flat_list = []
    for d in (cache_files, dep_cache_files):
        for src, (meta, data) in d.items():
            triples_as_flat_list.extend([
                shell.quote(src.path),
                shell.quote(meta.path),
                shell.quote(data.path),
            ])
    return triples_as_flat_list

def _flatten_cache_dict(cache_files):
    result = []
    for meta, data in cache_files.values():
        result.append(meta)
        result.append(data)
    return result

def _is_external_src(src_file):
    return src_file.path.startswith("external/")

def _extract_srcs(srcs):
    direct_src_files = []
    for src in srcs:
        for f in src.files.to_list():
            if f.extension in PY_EXTENSIONS and not _is_external_src(f):
                direct_src_files.append(f)
    return direct_src_files

# Overview
# This aspect does the following:
# - Create an action to run mypy against the sources of `target`
#   - input of this action:
#     - source files of `target` and source files of all its deps.
#     - cache files produced by checking its deps.
#   - output of this action:
#     - mypy stderr+stdout in a file
#     - cache files produced by checking the source files of `target`
#   - this action depends on actions created for the deps, so that it always
#     has access to cache files produced by those actions.
# - Propagate the output of this action along the `deps` edge of the build graph.
# - Produces a OutputGroup which contains the output of all the actions created
#   along the build graph so that one can use bazel commandline to mark all those
#   actions as required and to make them run.
def _mypy_aspect_impl(target, ctx):
    if (ctx.rule.kind not in PY_RULES or
        ctx.label.workspace_root.startswith("external")):
        return []
    base_rule = ctx.rule
    debug = ctx.attr._debug
    mypy_config_file = ctx.file._mypy_config

    # Get the cache files generated by running mypy against the deps.
    dep_cache_files = {}
    for dep in ctx.rule.attr.deps:
        if MyPyAspectInfo in dep:
            dep_cache_files.update(dep[MyPyAspectInfo].cache)

    direct_src_files = []
    if hasattr(base_rule.attr, "srcs"):
        direct_src_files = _extract_srcs(base_rule.attr.srcs)

    # It's possible that this target does not have srcs (py_wheel for example).
    # However, if the user requests to type check a py_wheel, we should make sure
    # its python transitive deps get checked.
    if direct_src_files:
        # There are source files in this target to check. The check will result in
        # cache files. Request bazel to allocate those files now.
        cache_files = {}
        for src in direct_src_files:
            meta_file = ctx.actions.declare_file("{}.meta.json".format(src.basename))
            data_file = ctx.actions.declare_file("{}.data.json".format(src.basename))
            cache_files[src] = (meta_file, data_file)


        # The mypy stdout, which is expected to be produced by mypy_script.
        mypy_out = ctx.actions.declare_file("%s_mypy_out" % ctx.rule.attr.name)
        # The script to invoke mypy against this target.
        mypy_script = ctx.actions.declare_file(
            "%s_mypy_script" % ctx.rule.attr.name,
        )

        # Generated files are located in a different root dir than source files
        # Thus we need to let mypy know where to find both kinds in case in one analysis
        # both kinds are present.
        src_root_paths = sets.to_list(
            sets.make(
                [f.root.path for f in dep_cache_files.keys()] +
                [f.root.path for f in cache_files.keys()]),
        )

        all_src_files = direct_src_files + list(dep_cache_files.keys())
        substitutions = {
            "{MYPY_BIN}": ctx.executable._mypy.path,
            "{CACHE_MAP_TRIPLES}": " ".join(_sources_to_cache_map_triples(cache_files, dep_cache_files)),
            "{PACKAGE_ROOTS}": " ".join([
                "--package-root " + shell.quote(path or ".")
                for path in src_root_paths
            ]),
            "{SRCS}": " ".join([
                shell.quote(f.path)
                for f in all_src_files
            ]),
            "{VERBOSE_OPT}": "--verbose" if debug else "",
            "{VERBOSE_BASH}": "set -x" if debug else "",
            "{OUTPUT}": mypy_out.path,
            "{ADDITIONAL_MYPYPATH}": ":".join([p for p in src_root_paths if p]),
            "{MYPY_INI}": mypy_config_file.path,
        }
        ctx.actions.expand_template(
            template = ctx.file._mypy_sh,
            output = mypy_script,
            substitutions = substitutions,
            is_executable = True,
        )

        # We want mypy to follow imports, so all the source files of the dependencies
        # are need altoghther to check this target.
        ctx.actions.run(
            outputs = [mypy_out] + _flatten_cache_dict(cache_files),
            inputs = depset(
                all_src_files +
                [mypy_config_file] +
                _flatten_cache_dict(dep_cache_files)  # cache generated by analyzing deps
            ),
            tools = [ctx.executable._mypy],
            executable = mypy_script,
            mnemonic = "MyPy",
            progress_message = "Type-checking %s" % ctx.label,
            use_default_shell_env = True,
        )
        dep_cache_files.update(cache_files)
    transitive_mypy_outs = []
    for dep in ctx.rule.attr.deps:
        if OutputGroupInfo in dep:
            if hasattr(dep[OutputGroupInfo], "mypy"):
                transitive_mypy_outs.append(dep[OutputGroupInfo].mypy)

    return [
        OutputGroupInfo(
            # We may not need to run mypy against this target, but we request
            # all its dependencies to be checked, recursively, but demanding the output
            # of those checks.
            mypy = depset([mypy_out] if direct_src_files else [], transitive=transitive_mypy_outs),
        ),
        MyPyAspectInfo(out = mypy_out if direct_src_files else None, cache = dep_cache_files),
    ]

mypy_aspect = aspect(
    implementation = _mypy_aspect_impl,
    attr_aspects = ["deps"],
    attrs = DEFAULT_ATTRS,
)
