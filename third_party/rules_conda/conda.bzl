load(":utils.bzl", "CONDA_EXT_MAP", "ENV_VAR_SEPARATOR_MAP", "EXECUTE_TIMEOUT", "INSTALLER_SCRIPT_EXT_MAP", "PYTHON_EXT_MAP", "execute_waitable_windows", "get_arch", "get_os", "get_path_envar", "windowsify")

# libmamba version
LIBMAMBA_SOLVER_VERSION = "23.5.0"

# CONDA CONFIGURATION
CONDA_MAJOR = "3"
CONDA_MINOR = "py310_23.5.2-0"
CONDA_SHA = {
    "Linux": {
        "aarch64": "24f7fe91032538cf2d9748facabae346e45e46ca21bb5f2d5875b7865dca6fa4",
        "ppc64le": "3a76e4e400271d1589770dac8f696b03d1faf45fee57da38e8c399b6cb0daadb",
        "s390x": "7a65b8593db0ec4b561b9968daca7c7c4f5f95cb21fe717ba895fded924bc056",
        "x86_64": "ea5e6e8a3d5a0247b9df85382d27220fac8e59b5778fd313c5913879cd9baafc",
    },
    "MacOSX": {
        "arm64": "71b7ca2ae4068504f9c6dab30fd6e83694086241156af1e319d598befe0f3a26",
        "x86_64": "13c57188a4bcb7462a7580c9ddf8ff2d301e353c835d33042a51a231667cf25d",
    },
    "Windows": {
        "x86_64": "e15638645b34921098a3f760fd8af07e53a427f59b99a0f049420a7751cbbc05",
    },
}
CONDA_INSTALLER_NAME_TEMPLATE = "Miniconda{major}-{minor}-{os}-{arch}{ext}"
CONDA_BASE_URL = "https://repo.anaconda.com/miniconda/"

INSTALLER_DIR = "installer"
INSTALLER_FLAGS = {
    "Linux": ["-b", "-f", "-p", "{}"],
    "MacOSX": ["-b", "-f", "-p", "{}"],
    "Windows": ["/InstallationType=JustMe", "/AddToPath=0", "/RegisterPython=0", "/S", "/D={}"],
}

CONDA_BUILD_FILE_TEMPLATE = """# This file was automatically generated by rules_conda
exports_files(
    [
        '{conda}',
        '{python},
    ]
)
"""

def _get_installer_flags(rctx, dir):
    os = get_os(rctx)
    flags = INSTALLER_FLAGS[os]

    # insert directory
    dir = rctx.path(dir)
    if os == "Windows":
        dir = windowsify(dir)
    return flags[:-1] + [flags[-1].format(dir)]

# download conda installer
def _download_conda(rctx):
    rctx.report_progress("Downloading conda installer")
    os = get_os(rctx)
    arch = get_arch(rctx)
    ext = INSTALLER_SCRIPT_EXT_MAP[os]

    url = CONDA_BASE_URL + CONDA_INSTALLER_NAME_TEMPLATE.format(major = CONDA_MAJOR, minor = CONDA_MINOR, os = os, arch = arch, ext = ext)
    sha = CONDA_SHA

    output = "{}/install{}".format(INSTALLER_DIR, ext)

    # download from url to output
    rctx.download(
        url = url,
        output = output,
        sha256 = sha[os][arch],
        executable = True,
    )
    return output

# install conda locally
def _install_conda(rctx, installer):
    rctx.report_progress("Installing conda")
    os = get_os(rctx)
    installer_flags = _get_installer_flags(rctx, rctx.attr.conda_dir)

    path_envar = get_path_envar(rctx)

    args = [rctx.path(installer)] + installer_flags

    # Strip environment variables when installing conda to make sure
    # any activated conda environment would not affect the installer.
    # Also, since the installer writes to $HOME which breaks hermecity, we make it
    # write to the repo dir.
    install_conda_env = {
        "HOME": rctx.attr.conda_dir,
        "PATH": path_envar,
    }

    # execute installer with flags adjusted to OS
    if os == "Windows":
        install_conda_env.update({"CONDA_DLL_SEARCH_MODIFICATION_ENABLE": ""})

        # TODO: fix always returning 0
        # it seems that either miniconda installer returns 0 even on failure or the wrapper does something wrong
        # also stdout and stderr are always empty
        result = execute_waitable_windows(rctx, args, quiet = rctx.attr.quiet, environment = install_conda_env, timeout = rctx.attr.timeout)
    else:
        result = rctx.execute(args, quiet = rctx.attr.quiet, environment = install_conda_env, timeout = rctx.attr.timeout)

    if result.return_code:
        fail("Failure installing conda.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

    # The conda entrypoint has a shebang line that usually points to the python in the installation
    # however, if that shebang line were be too long (>127), conda would fallback to rely on
    # PATH. This is problematic because we do not have a reliable way to manipulate PATH.
    # Therefore, we expose the python interpreter (thus the right bin/ path) so that later invocations
    # of the conda command can setup the right PATH env.
    conda_entrypoint = rctx.path("{}/condabin/conda{}".format(rctx.attr.conda_dir, CONDA_EXT_MAP[os]))
    python_executable = "python{}".format(PYTHON_EXT_MAP[os])
    interpreter_path = python_executable if os == "Windows" else "bin/{}".format(python_executable)
    python = rctx.path("{}/{}".format(
        rctx.attr.conda_dir,
        interpreter_path,
    ))
    additional_paths = [str(rctx.path(python).dirname)]
    if os == "Windows":
        additional_paths = additional_paths + [str(rctx.path("{}/Library/bin".format(rctx.attr.conda_dir)))]
    additional_paths = additional_paths + [path_envar]
    actual_environment = {"HOME": rctx.attr.conda_dir, "PATH": ENV_VAR_SEPARATOR_MAP[os].join(additional_paths)}

    # install mamba solver.
    install_mamba_result = rctx.execute(
        [
            conda_entrypoint,
            "install",
            "-n",
            "base",
            "conda-libmamba-solver={}".format(LIBMAMBA_SOLVER_VERSION),
            "-y",
        ],
        quiet = rctx.attr.quiet,
        working_directory = rctx.attr.conda_dir,
        environment = actual_environment,
        timeout = rctx.attr.timeout,
    )

    if install_mamba_result.return_code:
        print("Failure installing conda-libmamba-solver.")
        print("stdout: \n", result.stdout)
        print("stderr: \n", result.stderr)
        fail("Failure installing conda-libmamba-solver.")

    return conda_entrypoint, python

# create BUILD file with exposed conda binary
def _create_conda_build_file(rctx, conda_entrypoint, conda_base_python):
    conda = "{}/{}".format(rctx.attr.conda_dir, conda_entrypoint)
    python = "{}/{}".format(rctx.attr.conda_dir, conda_base_python)
    rctx.file(
        "BUILD",
        content = CONDA_BUILD_FILE_TEMPLATE.format(conda = conda, python = python),
    )

def _load_conda_impl(rctx):
    installer = _download_conda(rctx)
    conda_entrypoint, conda_base_python = _install_conda(rctx, installer)
    _create_conda_build_file(rctx, conda_entrypoint, conda_base_python)

load_conda_rule = repository_rule(
    _load_conda_impl,
    attrs = {
        "conda_dir": attr.string(mandatory = True),
        "quiet": attr.bool(
            default = True,
            doc = "False if conda output should be shown",
        ),
        "timeout": attr.int(
            default = EXECUTE_TIMEOUT,
            doc = "Timeout in seconds for each execute action",
        ),
    },
)
