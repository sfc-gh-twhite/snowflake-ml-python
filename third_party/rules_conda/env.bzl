load(":utils.bzl", "CONDA_EXT_MAP", "EXECUTE_TIMEOUT", "PYTHON_EXT_MAP", "get_os", "get_path_envar")

BUILD_FILE_CONTENT = """# This file was automatically generated by rules_conda
package(default_visibility = ["//visibility:public"])


load("@bazel_tools//tools/python:toolchain.bzl", "py_runtime_pair")

py_runtime(
    name = "{name}",
    files = glob(["{env_path}/**/*"], exclude_directories = 0),
    interpreter = "{env_path}/{interpreter_path}",
    python_version = "PY{py_major}",
    coverage_tool = {coverage_tool_target},
)

filegroup(
    name = "coverage_tool",
    srcs = [{coverage_tool_path}],
)
"""

def _conda_cmd(rctx, conda_args, environment = {}):
    path_envar = get_path_envar(rctx)
    conda_entrypoint = Label("@{}//:{}/condabin/conda{}".format(
        rctx.attr.conda_repo,
        rctx.attr.conda_dir,
        CONDA_EXT_MAP[get_os(rctx)],
    ))
    python = Label("@{}//:{}/bin/python".format(
        rctx.attr.conda_repo,
        rctx.attr.conda_dir,
    ))
    actual_environment = {"PATH": "{}:{}".format(rctx.path(python).dirname, path_envar)}
    actual_environment.update(environment)
    environment_args = ["{}={}".format(env, val) for env, val in actual_environment.items()]

    return rctx.execute(
        # all environment variables are stripped. PATH and environment variables passed in are
        # added above. this is to prevent the conda_entrypoint from recognizing the conda
        # environment (if any) where bazel was invoked.
        ["env", "-i"] + environment_args + [conda_entrypoint] + conda_args,
        quiet = rctx.attr.quiet,
        timeout = rctx.attr.timeout,
    )

# clean conda caches and unused packages
def _clean(rctx):
    rctx.report_progress("Cleaning up")

    result = _conda_cmd(rctx, ["clean", "-a", "-y"])
    if result.return_code:
        fail("Failure cleaning up.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

def _create_empty_environment(rctx, env_name):
    rctx.report_progress("Creating empty conda environment, to be populated afterwards")
    result = _conda_cmd(rctx, ["create", "-y", "-p", "./{}".format(env_name)])
    if result.return_code:
        fail("Failure creating empty environment.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

def _update_environment(rctx, env_name, env_file):
    rctx.report_progress("Updating empty conda environment to populate it")
    result = _conda_cmd(
        rctx,
        ["env", "update", "--solver", "libmamba", "-f", env_file, "-p", "./{}".format(env_name)],
        environment = {"MAMBA_USE_LOCKFILES": "false"},
    )
    if result.return_code:
        fail("Failure updating environment.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

# create new local conda environment from file
def _create_environment(rctx, env_name):
    rctx.report_progress("Creating conda environment")

    # path to env file as string
    env_file = rctx.path(rctx.attr.environment)

    _create_empty_environment(rctx, env_name)
    _update_environment(rctx, env_name, env_file)

# get installed python version
def _get_py_version(rctx, env_path, interpreter_path):
    interpreter = "{}/{}".format(env_path, interpreter_path)
    result = rctx.execute([rctx.path(interpreter), "--version"], timeout = rctx.attr.timeout)
    output = result.stdout if result.stdout else result.stderr
    return output.replace("Python ", "")

# get major version number
def _get_major(version):
    return int(version.partition(".")[0])

# create BUILD file with py_runtime
def _create_env_build_file(rctx, env_name):
    os = get_os(rctx)
    python_executable = "python{}".format(PYTHON_EXT_MAP[os])
    interpreter_path = python_executable if os == "Windows" else "bin/{}".format(python_executable)

    py_version = _get_py_version(rctx, env_name, interpreter_path)
    py_major = _get_major(py_version)

    if py_major != 3:
        fail("Only Python 3 is supported. Your Python version is: {}.".format(py_version))

    coverage_tool_path = "{}/bin/coverage".format(env_name)
    coverage_tool_target = "\"coverage_tool\""
    coverage_tool_path_fmt = "\"{}\"".format(coverage_tool_path)
    ls_result = rctx.execute(["ls", rctx.path(coverage_tool_path)])
    if ls_result.return_code != 0:
        print("Coverage tool not found in {}. Coverage support disabled.".format(env_name))
        coverage_tool_target = "None"
        coverage_tool_path_fmt = ""

    rctx.file(
        "BUILD",
        content = BUILD_FILE_CONTENT.format(
            name = "python_runtime",
            env_path = env_name,
            interpreter_path = interpreter_path,
            py_major = py_major,
            coverage_tool_target = coverage_tool_target,
            coverage_tool_path = coverage_tool_path_fmt,
        ),
    )

def _conda_create_impl(rctx):
    env_name = rctx.name
    _create_environment(rctx, env_name)
    if rctx.attr.clean:
        _clean(rctx)
    _create_env_build_file(rctx, env_name)

conda_create_rule = repository_rule(
    _conda_create_impl,
    attrs = {
        "conda_repo": attr.string(mandatory = True),
        "conda_dir": attr.string(mandatory = True),
        "environment": attr.label(
            mandatory = True,
            allow_single_file = True,
            doc = "The label of the environment.yml file.",
        ),
        "quiet": attr.bool(
            default = True,
            doc = "False if conda output should be shown",
        ),
        "timeout": attr.int(
            default = EXECUTE_TIMEOUT,
            doc = "Timeout in seconds for each execute action",
        ),
        "clean": attr.bool(
            default = False,
            doc = "True if conda cache should be cleaned",
        ),
    },
)
